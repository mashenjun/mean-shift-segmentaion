
#include <iostream>
#include <typeinfo>
#include <opencv2/opencv.hpp>

using namespace std;
using namespace cv;

void customHoughCircles(  const cv::Mat                &ImageGRAY,
                          std::vector<cv::Vec3f> &detectedCircles,      // OUT
                          const int              numberOfBestCirclesReturned, // 1 - numberOfBestCirclesReturned (sorted)
                          const int              accumDivider,                // 2 - accumulator resolution (sizeImage/XXX)
                          const double           cannyHighThresh,             // 3 - Canny high threshold (low = 50%)
                          const double           minRadius,                   // 4 - min radius
                          const double           maxRadius,                   // 5 - max radius
                          const int              radiiNumb,                   // 6 - number of radii to check
                          const double           thetaStep_Degrees            // 7 - resolution of theta (degrees!)
);

void part1_1();
void part1_2();
void part1_3();
void part2_1();
void part2_2();
void part2_3();
void part3();
void debug_checkmatinfo(cv::Mat target);
double get_distance(int x1,int y1, int x2, int y2, Mat data);
std::pair<int,int> calculnewmode(int x, int y, Mat data);
int  get_UKernel_result(double inputS, double inputR);



std::string  PATH_Circles = "./images/circles.png";
std::string  PATH_Face    = "./images/face2.png";
std::string  PATH_Flower  = "/home/mashenjun/WorkSpace/mean-shift/images/flower.png";


int para_hs = 15;
int para_hr = 15;
double para_threshold = 25;
int max_iteration = 5;
std::pair <int,int> result;
vector<int> x_list ;
vector<int> y_list ;
vector<Vec3f> colour_list;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int main()
{

    // Uncomment the part of the exercise that you wish to implement.
    // For the final submission all implemented parts should be uncommented.

//    part1_1();
//    part1_2();
//    part1_3();
//    part2_1();
//    part2_2();
//    part2_3();
    part3();

    std::cout <<                                                                                                   std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    END    /////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout <<                                                                                                   std::endl;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void part1_1()
{
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    Part 1 - 1    //////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;

    cv::Mat       im_Circles_BGR = cv::imread( PATH_Circles );
    // BGR to Gray
    cv::Mat                       im_Circles_Gray;
    cv::cvtColor( im_Circles_BGR, im_Circles_Gray, cv::COLOR_BGR2GRAY );
    // Synthetic image - No Blurring necessary for denoising !!!

    // Perform the steps described in the exercise sheet

    // Show results
    // using **cv::imshow and cv::waitKey()** and when necessary **std::cout**
    // In the end, after the last cv::waitKey(), use **cv::destroyAllWindows()**

    cv::destroyAllWindows();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void part1_2()
{
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    Part 1 - 2    //////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;

    cv::Mat im_Circles_BGR = cv::imread( PATH_Circles );
    // BGR to Gray
    cv::Mat                       im_Circles_Gray;
    cv::cvtColor( im_Circles_BGR, im_Circles_Gray, cv::COLOR_BGR2GRAY );
    // Synthetic image - No Blurring necessary for denoising !!!

    // Perform the steps described in the exercise sheet

    // Show results
    // using **cv::imshow and cv::waitKey()** and when necessary **std::cout**
    // In the end, after the last cv::waitKey(), use **cv::destroyAllWindows()**
    // If needed perform normalization of the image to be displayed

    cv::destroyAllWindows();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void part1_3()
{
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    Part 1 - 3    //////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;

    std::cout << std::endl << "Please Wait... CustomHoughCircles @ face..." << std::endl;

    cv::Mat im_Face_BGR = cv::imread( PATH_Face );
    cv::Mat im_Face_Gray;

    // BGR to Gray
    cv::cvtColor( im_Face_BGR, im_Face_Gray, cv::COLOR_BGR2GRAY );
    // Blur for denoising
    cv::GaussianBlur( im_Face_Gray, im_Face_Gray, cv::Size(0,0), 1,3 );
    // Erosion/Dilation to eliminate some noise
    int erDil = 1;
    cv::erode(  im_Face_Gray, im_Face_Gray, cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(erDil,erDil) ) );
    cv::dilate( im_Face_Gray, im_Face_Gray, cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(erDil,erDil) ) );

    // Perform the steps described in the exercise sheet

    // Show results
    // using **cv::imshow and cv::waitKey()** and when necessary **std::cout**
    // In the end, after the last cv::waitKey(), use **cv::destroyAllWindows()**
    // If needed perform normalization of the image to be displayed

    cv::destroyAllWindows();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void part2_1()
{
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    Part 2 - 1    //////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;

    // read the image file flower
    cv::Mat                                              flower;
    cv::imread( PATH_Flower, cv::IMREAD_COLOR).convertTo(flower, CV_32FC3, (1./255.)); // image normalized [0,255] -> [0,1]
    cv::imshow("original image",                         flower);
    // gray version of flower
    cv::Mat              flower_gray;
    cv::cvtColor(flower, flower_gray, CV_BGR2GRAY);

    // Perform the steps described in the exercise sheet

    // Show results
    // using **cv::imshow and cv::waitKey()** and when necessary **std::cout**
    // In the end, after the last cv::waitKey(), use **cv::destroyAllWindows()**

    cv::destroyAllWindows();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void part2_2()
{
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    Part 2 - 2    //////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;

    std::cout << "\n" << "kmeans with color" << std::endl;

    // read the image file flower
    cv::Mat                                              flower;
    cv::imread( PATH_Flower, cv::IMREAD_COLOR).convertTo(flower, CV_32FC3, (1./255.)); // image normalized [0,255] -> [0,1]
    // gray version of flower
    cv::Mat              flower_gray;
    cv::cvtColor(flower, flower_gray, CV_BGR2GRAY);
    cv::imshow("original image", flower);

    // Perform the steps described in the exercise sheet

    // Show results
    // using **cv::imshow and cv::waitKey()** and when necessary **std::cout**
    // In the end, after the last cv::waitKey(), use **cv::destroyAllWindows()**

    cv::destroyAllWindows();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void part2_3()
{
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    Part 2 - 3    //////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;

    std::cout << "\n" << "kmeans with gray and pixel coordinates" << std::endl;

    // read the image file flower
    cv::Mat                                              flower;
    cv::imread( PATH_Flower, cv::IMREAD_COLOR).convertTo(flower, CV_32FC3, (1./255.)); // image normalized [0,255] -> [0,1]
    // gray version of flower
    cv::Mat              flower_gray;
    cv::cvtColor(flower, flower_gray, CV_BGR2GRAY);
    cv::imshow("original image", flower);

    // Perform the steps described in the exercise sheet

    // Show results
    // using **cv::imshow and cv::waitKey()** and when necessary **std::cout**
    // In the end, after the last cv::waitKey(), use **cv::destroyAllWindows()**

    cv::destroyAllWindows();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void part3()
{
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////    Part 3    //////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "////////////////////////////////////////////////////////////////////////////////////////////" << std::endl;

    // read the image file flower
    cv::Mat flower;
    cv::imread( PATH_Flower, cv::IMREAD_COLOR).convertTo(flower, CV_32FC3, (1./255.)); // image normalized [0,255] -> [0,1]
//    cv::imshow("original image",flower);
    // BGR -> LUV
    cv::Mat flower_luv;
    cv::cvtColor(flower, flower_luv, CV_BGR2Luv);
//    cv::imshow("flower_luv image",flower_luv);
//    cv::waitKey();
    cv::Mat finalResult = flower.clone();
//    for (int l = 0; l < flower_luv.channels(); ++l) {
//        std::cout << typeid(flower_luv.at<Vec3b>(0,0)[l]).name() << '\n';
//    }
    debug_checkmatinfo(flower_luv);


    std::cout << "------ Debug ------" << flower.type()<< "------ Debug ------" << std::endl;
    std::cout << "------ Start ------" << std::endl;
//    for(int i=0; i<flower_luv.rows; i++){
//        finalResult.at<Vec3b>(i,99) =  Vec3b(0,0,0);
//        finalResult.at<Vec3b>(i,100) =  Vec3b(0,0,0);
//        finalResult.at<Vec3b>(i,101) =  Vec3b(0,0,0);
//        finalResult.at<Vec3b>(i,102) =  Vec3b(0,0,0);
//        finalResult.at<Vec3b>(i,103) =  Vec3b(0,0,0);
//    }
    for(int i=0; i<flower_luv.rows; i++){
        for(int j=0; j<flower_luv.cols; j++){
            int current_x = j;
            int current_y = i;
//            std::cout << "------ [init] "<<j<<","<<i<<" ------" << std::endl;
            for (int k = 0; k < max_iteration; k++) {
                // You can now access the pixel value with cv::Vec3b
                std::pair <int,int> mode;
                mode = calculnewmode(current_x,current_y,flower_luv);
                if ((mode.first == current_x && mode.second == current_y) ||
                        (cv::norm(flower_luv.at<Vec3b>(mode.second,mode.first)-flower_luv.at<Vec3b>(current_y,current_x)) <= para_threshold)){
                    int x = mode.first;
                    int y = mode.second;
//                    std::cout << "------ [init] "<<j<<","<<i<< finalResult.at<Vec3b>(i,j)<<"[end] "<<mode.first<<","<<mode.second<<flower.at<Vec3b>(mode.second,mode.first)<<" ------" << std::endl;
//                    Vec3b intensity = flower_luv.at<Vec3b>(mode.second,mode.first);
                    Vec3f intensity = flower.at<Vec3f>(y, x);
                    float blue = intensity.val[0];
                    float green = intensity.val[1];
                    float red = intensity.val[2];
                    finalResult.at<cv::Vec3f>(i,j) = cv::Vec3f(blue,green,red);
                    x_list.push_back(x);
                    y_list.push_back(y);
                    colour_list.push_back(intensity);
                    break;
                }
                current_x = mode.first;
                current_y = mode.second;
            }
        }
    }
    std::cout << "------ Debug ------" << colour_list.size()<< "------ Debug ------" << std::endl;
    for (int l = 0; l <x_list.size() ; ++l) {

        cv:floodFill(finalResult,cv::Point(x_list.at(l),y_list.at(l)),(Scalar)colour_list.at(l),0);
    }

    cv::imshow("result image",finalResult);
    cv::waitKey();

    // Perform the steps described in the exercise sheet
    // Show results
    // using **cv::imshow and cv::waitKey()** and when necessary **std::cout**
    // In the end, after the last cv::waitKey(), use **cv::destroyAllWindows()**

    cv::destroyAllWindows();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void debug_checkmatinfo(cv::Mat target){
    std::cout << "target.dims = " << target.dims << "target.size = [";
    for(int i = 0; i < target.dims; ++i) {
        if(i) std::cout << " X ";
        std::cout << target.size[i];
    }
    std::cout << "] target.channels = " << target.channels() << std::endl;
}

std::pair<int,int> calculnewmode(int x, int y, Mat data){
    // !!!!! Epanechnikov Kernel求导后实质上就是Uniform Kernel。
    int x_max = data.cols;
    int y_max = data.rows;

    int x_start = x-para_hs <0? 0: x-para_hs;
    int y_start = y-para_hs <0? 0: y-para_hs;
    int x_end = x+para_hs> x_max? x_max: x+para_hs;
    int y_end = y+para_hs> y_max? y_max: y+para_hs;
    double x_cum = 0;
    double y_cum = 0;
    double UKernel_result_cum = 0;

    for (int i=y_start; i < y_end; ++i) {
        for (int j=x_start; j < x_end; ++j) {
            double colour_diff = get_distance(x,y,j,i,data)/(double)(para_hr*para_hr);
            double distance_diff = (x-j)*(x-j)+(y-i)*(y-i) / (double)(para_hs*para_hs);
            double UKernel_result = get_UKernel_result(distance_diff,colour_diff);
            x_cum = x_cum + j*UKernel_result;
            y_cum = y_cum + i*UKernel_result;
            UKernel_result_cum = UKernel_result_cum+UKernel_result;
        }
    }

    if (UKernel_result_cum ==0 ){
        std::cout << "------  ------" << std::endl;
        result = std::make_pair (x,y);
    }
    else{
        int x_result = (int)x_cum/UKernel_result_cum>x_end-1? x_end-1: (int)x_cum/UKernel_result_cum;
        int y_result = (int)y_cum/UKernel_result_cum>y_end-1? y_end-1: (int)y_cum/UKernel_result_cum;
        result = std::make_pair (x_result,y_result);
    }
    return result;

}

//int get_UKernel_result(double input) {
//    return input>1?0:1;
//}

int get_UKernel_result(double inputS, double inputR) {
    int outputs = inputS>1?0:1;
    int outputr = inputR>1?0:1;
    return outputs*outputr;
}

double get_distance(int x1,int y1, int x2, int y2, Mat data){
    double p1 = (data.at<Vec3b>(y1,x1)[0]-data.at<Vec3b>(y2,x2)[0])*(data.at<Vec3b>(y1,x1)[0]-data.at<Vec3b>(y2,x2)[0]);
    double p2 = (data.at<Vec3b>(y1,x1)[1]-data.at<Vec3b>(y2,x2)[1])*(data.at<Vec3b>(y1,x1)[1]-data.at<Vec3b>(y2,x2)[1]);
    double p3 = (data.at<Vec3b>(y1,x1)[2]-data.at<Vec3b>(y2,x2)[2])*(data.at<Vec3b>(y1,x1)[2]-data.at<Vec3b>(y2,x2)[2]);
    return p1+p2+p3;
}
